/* Generated By:JavaCC: Do not edit this line. OscriptParserTokenManager.java */
package oscript.parser;


public class OscriptParserTokenManager implements OscriptParserConstants 
{
	static private boolean stillInFormalComment;	

	private static final int jjStopStringLiteralDfa_0(int pos, Int64 active0, Int64 active1) {

		switch (pos) {
		case 0:
			if (BitHacker.and(active0, X2000000).isNotZero() || BitHacker.and(active1, X20000000008000).isNotZero())
				return 10;
			if (BitHacker.and(active0, X140).isNotZero() || BitHacker.and(active1, X200400000000).isNotZero())
				return 2;
			if (BitHacker.and(active1, X100).isNotZero())
				return 8;
			if (BitHacker.and(active0, X3FFFFFFDF80000).isNotZero()) {
				jjmatchedKind = 67;
				return 40;
			}
			return -1;
		case 1:
			if (BitHacker.and(active0, X100).isNotZero())
				return 0;
			if (BitHacker.and(active0, X3FFFFDFCF80000).isNotZero()) {
				if (jjmatchedPos != 1) {
					jjmatchedKind = 67;
					jjmatchedPos = 1;
				}
				return 40;
			}
			if (BitHacker.and(active0, X201000000).isNotZero())
				return 40;
			if (BitHacker.and(active1, X200000000000).isNotZero())
				return 60;
			return -1;
		case 2:
			if (BitHacker.and(active0, X35FFDD7CF80000).isNotZero()) {
				if (jjmatchedPos != 2) {
					jjmatchedKind = 67;
					jjmatchedPos = 2;
				}
				return 40;
			}
			if (BitHacker.and(active0, XA002080000000).isNotZero())
				return 40;
			return -1;
		case 3:
			if (BitHacker.and(active0, X24BF9D68F80000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 3;
				return 40;
			}
			if (BitHacker.and(active0, X11404014000000).isNotZero())
				return 40;
			return -1;
		case 4:
			if (BitHacker.and(active0, X42F8D48900000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 4;
				return 40;
			}
			if (BitHacker.and(active0, X20901020680000).isNotZero())
				return 40;
			return -1;
		case 5:
			if (BitHacker.and(active0, X4218548800000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 5;
				return 40;
			}
			if (BitHacker.and(active0, XE0800100000).isNotZero())
				return 40;
			return -1;
		case 6:
			if (BitHacker.and(active0, X4210500800000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 6;
				return 40;
			}
			if (BitHacker.and(active0, X8048000000).isNotZero())
				return 40;
			return -1;
		case 7:
			if (BitHacker.and(active0, X100800000).isNotZero())
				return 40;
			if (BitHacker.and(active0, X4210400000000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 7;
				return 40;
			}
			return -1;
		case 8:
			if (BitHacker.and(active0, X200400000000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 8;
				return 40;
			}
			if (BitHacker.and(active0, X4010000000000).isNotZero())
				return 40;
			return -1;
		case 9:
			if (BitHacker.and(active0, X200000000000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 9;
				return 40;
			}
			if (BitHacker.and(active0, X400000000).isNotZero())
				return 40;
			return -1;
		case 10:
			if (BitHacker.and(active0, X200000000000).isNotZero()) {
				jjmatchedKind = 67;
				jjmatchedPos = 10;
				return 40;
			}
			return -1;
		default:
			return -1;
		}
	}

	private static final int jjStartNfa_0(int pos, Int64 active0, Int64 active1) {
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
	}

	static private final int jjStopAtPos(int pos, int kind) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}

	static private final int jjStartNfaWithStates_0(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_0(state, pos + 1);
	}

	static private final int jjMoveStringLiteralDfa0_0() {
		switch (curChar) {
		case 33:
			jjmatchedKind = 83;
			return jjMoveStringLiteralDfa1_0(X0, X4000000);
		case 35:
			return jjMoveStringLiteralDfa1_0(X200, X0);
		case 37:
			jjmatchedKind = 102;
			return jjMoveStringLiteralDfa1_0(X0, X2000000000000);
		case 38:
			jjmatchedKind = 99;
			return jjMoveStringLiteralDfa1_0(X0, X400010000000);
		case 39:
			return jjMoveStringLiteralDfa1_0(X0, X100);
		case 40:
			return jjStopAtPos(0, 70);
		case 41:
			return jjStopAtPos(0, 71);
		case 42:
			jjmatchedKind = 97;
			return jjMoveStringLiteralDfa1_0(X0, X100000000000);
		case 43:
			jjmatchedKind = 95;
			return jjMoveStringLiteralDfa1_0(X0, X40020000000);
		case 44:
			return jjStopAtPos(0, 78);
		case 45:
			jjmatchedKind = 96;
			return jjMoveStringLiteralDfa1_0(X0, X80040000000);
		case 46:
			jjmatchedKind = 79;
			return jjMoveStringLiteralDfa1_0(X2000000, X20000000000000);
		case 47:
			jjmatchedKind = 98;
			return jjMoveStringLiteralDfa1_0(X140, X200000000000);
		case 58:
			return jjStopAtPos(0, 86);
		case 59:
			return jjStopAtPos(0, 77);
		case 60:
			jjmatchedKind = 82;
			return jjMoveStringLiteralDfa1_0(X0, X4008001000000);
		case 61:
			jjmatchedKind = 80;
			return jjMoveStringLiteralDfa1_0(X0, X800000);
		case 62:
			jjmatchedKind = 81;
			return jjMoveStringLiteralDfa1_0(X0, X18030002000000);
		case 63:
			return jjStopAtPos(0, 85);
		case 91:
			return jjStopAtPos(0, 75);
		case 93:
			return jjStopAtPos(0, 76);
		case 94:
			jjmatchedKind = 101;
			return jjMoveStringLiteralDfa1_0(X0, X1000000000000);
		case 98:
			return jjMoveStringLiteralDfa1_0(X80000, X0);
		case 99:
			return jjMoveStringLiteralDfa1_0(XF00000, X0);
		case 100:
			return jjMoveStringLiteralDfa1_0(X1000000, X0);
		case 101:
			return jjMoveStringLiteralDfa1_0(X1C000000, X0);
		case 102:
			return jjMoveStringLiteralDfa1_0(X1E0000000, X0);
		case 105:
			return jjMoveStringLiteralDfa1_0(XE00000000, X0);
		case 109:
			return jjMoveStringLiteralDfa1_0(X1000000000, X0);
		case 110:
			return jjMoveStringLiteralDfa1_0(X6000000000, X0);
		case 112:
			return jjMoveStringLiteralDfa1_0(X38000000000, X0);
		case 114:
			return jjMoveStringLiteralDfa1_0(X40000000000, X0);
		case 115:
			return jjMoveStringLiteralDfa1_0(X380000000000, X0);
		case 116:
			return jjMoveStringLiteralDfa1_0(X3C00000000000, X0);
		case 117:
			return jjMoveStringLiteralDfa1_0(X4000000000000, X0);
		case 118:
			return jjMoveStringLiteralDfa1_0(X18000000000000, X0);
		case 119:
			return jjMoveStringLiteralDfa1_0(X20000000000000, X0);
		case 123:
			return jjStopAtPos(0, 73);
		case 124:
			jjmatchedKind = 100;
			return jjMoveStringLiteralDfa1_0(X0, X800008000000);
		case 125:
			return jjStopAtPos(0, 74);
		case 126:
			return jjStopAtPos(0, 84);
		default:
			return jjMoveNfa_0(3, 0);
		}
	}

	static private final int jjMoveStringLiteralDfa1_0(Int64 active0, Int64 active1) {
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0, active1);
			return 1;
		}
		switch (curChar) {
		case 33:
			if (BitHacker.and(active0, X200).isNotZero())
				return jjStopAtPos(1, 9);
			break;
		case 38:
			if (BitHacker.and(active1, X10000000).isNotZero())
				return jjStopAtPos(1, 92);
			break;
		case 42:
			if (BitHacker.and(active0, X100).isNotZero())
				return jjStartNfaWithStates_0(1, 8, 0);
			break;
		case 43:
			if (BitHacker.and(active1, X20000000).isNotZero())
				return jjStopAtPos(1, 93);
			break;
		case 45:
			if (BitHacker.and(active1, X40000000).isNotZero())
				return jjStopAtPos(1, 94);
			break;
		case 46:
			if (BitHacker.and(active1, X20000000000000).isNotZero()) {
				jjmatchedKind = 117;
				jjmatchedPos = 1;
			}
			return jjMoveStringLiteralDfa2_0(active0, X2000000, active1, X0);
		case 47:
			if (BitHacker.and(active0, X40).isNotZero())
				return jjStopAtPos(1, 6);
			break;
		case 60:
			if (BitHacker.and(active1, X8000000000).isNotZero()) {
				jjmatchedKind = 103;
				jjmatchedPos = 1;
			}
			return jjMoveStringLiteralDfa2_0(active0, X0, active1, X4000000000000);
		case 61:
			if (BitHacker.and(active1, X800000).isNotZero())
				return jjStopAtPos(1, 87);
			else if (BitHacker.and(active1, X1000000).isNotZero())
				return jjStopAtPos(1, 88);
			else if (BitHacker.and(active1, X2000000).isNotZero())
				return jjStopAtPos(1, 89);
			else if (BitHacker.and(active1, X4000000).isNotZero())
				return jjStopAtPos(1, 90);
			else if (BitHacker.and(active1, X40000000000).isNotZero())
				return jjStopAtPos(1, 106);
			else if (BitHacker.and(active1, X80000000000).isNotZero())
				return jjStopAtPos(1, 107);
			else if (BitHacker.and(active1, X100000000000).isNotZero())
				return jjStopAtPos(1, 108);
			else if (BitHacker.and(active1, X200000000000).isNotZero())
				return jjStartNfaWithStates_0(1, 109, 60);
			else if (BitHacker.and(active1, X400000000000).isNotZero())
				return jjStopAtPos(1, 110);
			else if (BitHacker.and(active1, X800000000000).isNotZero())
				return jjStopAtPos(1, 111);
			else if (BitHacker.and(active1, X1000000000000).isNotZero())
				return jjStopAtPos(1, 112);
			else if (BitHacker.and(active1, X2000000000000).isNotZero())
				return jjStopAtPos(1, 113);
			break;
		case 62:
			if (BitHacker.and(active1, X10000000000).isNotZero()) {
				jjmatchedKind = 104;
				jjmatchedPos = 1;
			}
			return jjMoveStringLiteralDfa2_0(active0, X0, active1, X18020000000000);
		case 97:
			return jjMoveStringLiteralDfa2_0(active0, X8000020300000, active1, X0);
		case 101:
			return jjMoveStringLiteralDfa2_0(active0, X42000000000, active1, X0);
		case 102:
			if (BitHacker.and(active0, X200000000).isNotZero())
				return jjStartNfaWithStates_0(1, 33, 40);
			break;
		case 104:
			return jjMoveStringLiteralDfa2_0(active0, X20C00000000000, active1, X0);
		case 105:
			return jjMoveStringLiteralDfa2_0(active0, X1040000000, active1, X0);
		case 108:
			return jjMoveStringLiteralDfa2_0(active0, X4000000, active1, X0);
		case 109:
			return jjMoveStringLiteralDfa2_0(active0, X800000000, active1, X0);
		case 110:
			return jjMoveStringLiteralDfa2_0(active0, X4000400000000, active1, X0);
		case 111:
			if (BitHacker.and(active0, X1000000).isNotZero())
				return jjStartNfaWithStates_0(1, 24, 40);
			return jjMoveStringLiteralDfa2_0(active0, X10000080C00000, active1, X0);
		case 114:
			return jjMoveStringLiteralDfa2_0(active0, X3018000080000, active1, X0);
		case 116:
			return jjMoveStringLiteralDfa2_0(active0, X80000000000, active1, X0);
		case 117:
			return jjMoveStringLiteralDfa2_0(active0, X124100000000, active1, X0);
		case 118:
			return jjMoveStringLiteralDfa2_0(active0, X10000000, active1, X0);
		case 120:
			return jjMoveStringLiteralDfa2_0(active0, X8000000, active1, X0);
		case 121:
			return jjMoveStringLiteralDfa2_0(active0, X200000000000, active1, X0);
		case 123:
			if (BitHacker.and(active1, X100).isNotZero())
				return jjStopAtPos(1, 72);
			break;
		case 124:
			if (BitHacker.and(active1, X8000000).isNotZero())
				return jjStopAtPos(1, 91);
			break;
		default:
			break;
		}
		return jjStartNfa_0(0, active0, active1);
	}

	static private final int jjMoveStringLiteralDfa2_0(Int64 old0, Int64 active0, Int64 old1, Int64 active1) {
		active0 = BitHacker.and(active0, old0);
		active1 = BitHacker.and(active1, old1);
		if (BitHacker.or(active0, active1).isZero())
			return jjStartNfa_0(0, old0, old1);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(1, active0, active1);
			return 2;
		}
		switch (curChar) {
		case 46:
			if (BitHacker.and(active0, X2000000).isNotZero())
				return jjStopAtPos(2, 25);
			break;
		case 61:
			if (BitHacker.and(active1, X4000000000000).isNotZero())
				return jjStopAtPos(2, 114);
			else if (BitHacker.and(active1, X8000000000000).isNotZero())
				return jjStopAtPos(2, 115);
			break;
		case 62:
			if (BitHacker.and(active1, X20000000000).isNotZero()) {
				jjmatchedKind = 105;
				jjmatchedPos = 2;
			}
			return jjMoveStringLiteralDfa3_0(active0, X0, active1, X10000000000000);
		case 97:
			return jjMoveStringLiteralDfa3_0(active0, X80010000000, active1, X0);
		case 98:
			return jjMoveStringLiteralDfa3_0(active0, X20000000000, active1, X0);
		case 100:
			return jjMoveStringLiteralDfa3_0(active0, X4000000000000, active1, X0);
		case 101:
			return jjMoveStringLiteralDfa3_0(active0, X80000, active1, X0);
		case 105:
			return jjMoveStringLiteralDfa3_0(active0, X30408000000000, active1, X0);
		case 108:
			return jjMoveStringLiteralDfa3_0(active0, X4020100000, active1, X0);
		case 110:
			return jjMoveStringLiteralDfa3_0(active0, X200140C00000, active1, X0);
		case 111:
			return jjMoveStringLiteralDfa3_0(active0, X10000000000, active1, X0);
		case 112:
			return jjMoveStringLiteralDfa3_0(active0, X100800000000, active1, X0);
		case 114:
			if (BitHacker.and(active0, X80000000).isNotZero())
				return jjStartNfaWithStates_0(2, 31, 40);
			else if (BitHacker.and(active0, X8000000000000).isNotZero())
				return jjStartNfaWithStates_0(2, 51, 40);
			return jjMoveStringLiteralDfa3_0(active0, X800000000000, active1, X0);
		case 115:
			return jjMoveStringLiteralDfa3_0(active0, X404000000, active1, X0);
		case 116:
			return jjMoveStringLiteralDfa3_0(active0, X40008200000, active1, X0);
		case 117:
			return jjMoveStringLiteralDfa3_0(active0, X1000000000000, active1, X0);
		case 119:
			if (BitHacker.and(active0, X2000000000).isNotZero())
				return jjStartNfaWithStates_0(2, 37, 40);
			break;
		case 120:
			return jjMoveStringLiteralDfa3_0(active0, X1000000000, active1, X0);
		case 121:
			if (BitHacker.and(active0, X2000000000000).isNotZero())
				return jjStartNfaWithStates_0(2, 49, 40);
			break;
		default:
			break;
		}
		return jjStartNfa_0(1, active0, active1);
	}

	static private final int jjMoveStringLiteralDfa3_0(Int64 old0, Int64 active0, Int64 old1, Int64 active1) {
		active0 = BitHacker.and(active0, old0);
		active1 = BitHacker.and(active1, old1);
		if (BitHacker.or(active0, active1).isZero())
			return jjStartNfa_0(1, old0, old1);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(2, active0, active1);
			return 3;
		}
		switch (curChar) {
		case 61:
			if (BitHacker.and(active1, X10000000000000).isNotZero())
				return jjStopAtPos(3, 116);
			break;
		case 97:
			return jjMoveStringLiteralDfa4_0(active0, X40080000, active1, X0);
		case 99:
			return jjMoveStringLiteralDfa4_0(active0, X200100200000, active1, X0);
		case 100:
			if (BitHacker.and(active0, X10000000000000).isNotZero())
				return jjStartNfaWithStates_0(3, 52, 40);
			break;
		case 101:
			if (BitHacker.and(active0, X4000000).isNotZero())
				return jjStartNfaWithStates_0(3, 26, 40);
			else if (BitHacker.and(active0, X1000000000000).isNotZero())
				return jjStartNfaWithStates_0(3, 48, 40);
			return jjMoveStringLiteralDfa4_0(active0, X4100008000000, active1, X0);
		case 105:
			return jjMoveStringLiteralDfa4_0(active0, X1000000000, active1, X0);
		case 108:
			if (BitHacker.and(active0, X10000000).isNotZero())
				return jjStartNfaWithStates_0(3, 28, 40);
			else if (BitHacker.and(active0, X4000000000).isNotZero())
				return jjStartNfaWithStates_0(3, 38, 40);
			return jjMoveStringLiteralDfa4_0(active0, X20020000100000, active1, X0);
		case 111:
			return jjMoveStringLiteralDfa4_0(active0, X800800000000, active1, X0);
		case 115:
			if (BitHacker.and(active0, X400000000000).isNotZero())
				return jjStartNfaWithStates_0(3, 46, 40);
			return jjMoveStringLiteralDfa4_0(active0, X20400000, active1, X0);
		case 116:
			return jjMoveStringLiteralDfa4_0(active0, X90400800000, active1, X0);
		case 117:
			return jjMoveStringLiteralDfa4_0(active0, X40000000000, active1, X0);
		case 118:
			return jjMoveStringLiteralDfa4_0(active0, X8000000000, active1, X0);
		default:
			break;
		}
		return jjStartNfa_0(2, active0, active1);
	}

	static private final int jjMoveStringLiteralDfa4_0(Int64 old0, Int64 active0, Int64 old1, Int64 active1) {
		active0 = BitHacker.and(active0, old0);
		active1 = BitHacker.and(active1, old1);
		if (BitHacker.or(active0, active1).isZero())
			return jjStartNfa_0(2, old0, old1);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(3, active0, X0);
			return 4;
		}
		switch (curChar) {
		case 97:
			return jjMoveStringLiteralDfa5_0(active0, X8400000000);
		case 101:
			if (BitHacker.and(active0, X20000000).isNotZero())
				return jjStartNfaWithStates_0(4, 29, 40);
			else if (BitHacker.and(active0, X20000000000000).isNotZero())
				return jjStartNfaWithStates_0(4, 53, 40);
			return jjMoveStringLiteralDfa5_0(active0, X10000100000);
		case 102:
			return jjMoveStringLiteralDfa5_0(active0, X4000000000000);
		case 104:
			if (BitHacker.and(active0, X200000).isNotZero())
				return jjStartNfaWithStates_0(4, 21, 40);
			return jjMoveStringLiteralDfa5_0(active0, X200000000000);
		case 105:
			return jjMoveStringLiteralDfa5_0(active0, XA0000800000);
		case 107:
			if (BitHacker.and(active0, X80000).isNotZero())
				return jjStartNfaWithStates_0(4, 19, 40);
			break;
		case 108:
			return jjMoveStringLiteralDfa5_0(active0, X40000000);
		case 110:
			if (BitHacker.and(active0, X1000000000).isNotZero())
				return jjStartNfaWithStates_0(4, 36, 40);
			return jjMoveStringLiteralDfa5_0(active0, X8000000);
		case 114:
			if (BitHacker.and(active0, X100000000000).isNotZero())
				return jjStartNfaWithStates_0(4, 44, 40);
			return jjMoveStringLiteralDfa5_0(active0, X40800000000);
		case 116:
			if (BitHacker.and(active0, X400000).isNotZero())
				return jjStartNfaWithStates_0(4, 22, 40);
			return jjMoveStringLiteralDfa5_0(active0, X100000000);
		case 119:
			if (BitHacker.and(active0, X800000000000).isNotZero())
				return jjStartNfaWithStates_0(4, 47, 40);
			break;
		default:
			break;
		}
		return jjStartNfa_0(3, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa5_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(3, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(4, active0, X0);
			return 5;
		}
		switch (curChar) {
		case 99:
			if (BitHacker.and(active0, X20000000000).isNotZero())
				return jjStartNfaWithStates_0(5, 41, 40);
			else if (BitHacker.and(active0, X80000000000).isNotZero())
				return jjStartNfaWithStates_0(5, 43, 40);
			return jjMoveStringLiteralDfa6_0(active0, X10000000000);
		case 100:
			return jjMoveStringLiteralDfa6_0(active0, X8000000);
		case 101:
			if (BitHacker.and(active0, X100000).isNotZero())
				return jjStartNfaWithStates_0(5, 20, 40);
			break;
		case 105:
			return jjMoveStringLiteralDfa6_0(active0, X4000100000000);
		case 108:
			return jjMoveStringLiteralDfa6_0(active0, X40000000);
		case 110:
			if (BitHacker.and(active0, X40000000000).isNotZero())
				return jjStartNfaWithStates_0(5, 42, 40);
			return jjMoveStringLiteralDfa6_0(active0, X400800000);
		case 114:
			return jjMoveStringLiteralDfa6_0(active0, X200000000000);
		case 116:
			if (BitHacker.and(active0, X800000000).isNotZero())
				return jjStartNfaWithStates_0(5, 35, 40);
			return jjMoveStringLiteralDfa6_0(active0, X8000000000);
		default:
			break;
		}
		return jjStartNfa_0(4, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa6_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(4, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(5, active0, X0);
			return 6;
		}
		switch (curChar) {
		case 99:
			return jjMoveStringLiteralDfa7_0(active0, X400000000);
		case 101:
			if (BitHacker.and(active0, X8000000000).isNotZero())
				return jjStartNfaWithStates_0(6, 39, 40);
			break;
		case 110:
			return jjMoveStringLiteralDfa7_0(active0, X4000000000000);
		case 111:
			return jjMoveStringLiteralDfa7_0(active0, X200100000000);
		case 115:
			if (BitHacker.and(active0, X8000000).isNotZero())
				return jjStartNfaWithStates_0(6, 27, 40);
			break;
		case 116:
			return jjMoveStringLiteralDfa7_0(active0, X10000000000);
		case 117:
			return jjMoveStringLiteralDfa7_0(active0, X800000);
		case 121:
			if (BitHacker.and(active0, X40000000).isNotZero())
				return jjStartNfaWithStates_0(6, 30, 40);
			break;
		default:
			break;
		}
		return jjStartNfa_0(5, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa7_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(5, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(6, active0, X0);
			return 7;
		}
		switch (curChar) {
		case 101:
			if (BitHacker.and(active0, X800000).isNotZero())
				return jjStartNfaWithStates_0(7, 23, 40);
			return jjMoveStringLiteralDfa8_0(active0, X4010400000000);
		case 110:
			if (BitHacker.and(active0, X100000000).isNotZero())
				return jjStartNfaWithStates_0(7, 32, 40);
			return jjMoveStringLiteralDfa8_0(active0, X200000000000);
		default:
			break;
		}
		return jjStartNfa_0(6, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa8_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(6, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(7, active0, X0);
			return 8;
		}
		switch (curChar) {
		case 100:
			if (BitHacker.and(active0, X10000000000).isNotZero())
				return jjStartNfaWithStates_0(8, 40, 40);
			else if (BitHacker.and(active0, X4000000000000).isNotZero())
				return jjStartNfaWithStates_0(8, 50, 40);
			break;
		case 105:
			return jjMoveStringLiteralDfa9_0(active0, X200000000000);
		case 111:
			return jjMoveStringLiteralDfa9_0(active0, X400000000);
		default:
			break;
		}
		return jjStartNfa_0(7, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa9_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(7, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(8, active0, X0);
			return 9;
		}
		switch (curChar) {
		case 102:
			if (BitHacker.and(active0, X400000000).isNotZero())
				return jjStartNfaWithStates_0(9, 34, 40);
			break;
		case 122:
			return jjMoveStringLiteralDfa10_0(active0, X200000000000);
		default:
			break;
		}
		return jjStartNfa_0(8, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa10_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(8, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(9, active0, X0);
			return 10;
		}
		switch (curChar) {
		case 101:
			return jjMoveStringLiteralDfa11_0(active0, X200000000000);
		default:
			break;
		}
		return jjStartNfa_0(9, active0, X0);
	}

	static private final int jjMoveStringLiteralDfa11_0(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_0(9, old0, X0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_0(10, active0, X0);
			return 11;
		}
		switch (curChar) {
		case 100:
			if (BitHacker.and(active0, X200000000000).isNotZero())
				return jjStartNfaWithStates_0(11, 45, 40);
			break;
		default:
			break;
		}
		return jjStartNfa_0(10, active0, X0);
	}

	static private final void jjCheckNAdd(int state) {
		if (jjrounds[state] != jjround) {
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	static private final void jjAddStates(int start, int end) {
		do {
			jjstateSet[jjnewStateCnt++] = jjnextStates[start];
		} while (start++ != end);
	}

	static private final void jjCheckNAddTwoStates(int state1, int state2) {
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	static private final void jjCheckNAddStates(int start, int end) {
		do {
			jjCheckNAdd(jjnextStates[start]);
		} while (start++ != end);
	}

	static private final int jjMoveNfa_0(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 60;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7FFFFFFF;
		for (;;) {
			if (++jjround == 0x7FFFFFFF)
				ReInitRounds();
			if (curChar < 64) {
				Int64 l = BitHacker.shift1(curChar);
				do {
					switch (jjstateSet[--i]) {
					case 60:
						if (BitHacker.and(XFFFF7FFEFFFFDBFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						else if (curChar == 47) {
							if (kind > 63)
								kind = 63;
							jjstateSet[jjnewStateCnt++] = 37;
						}
						break;
					case 2:
						if (BitHacker.and(XFFFF7BFEFFFFDBFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						else if (curChar == 42)
							jjstateSet[jjnewStateCnt++] = 0;
						break;
					case 3:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddStates(3, 9);
						else if (curChar == 36) {
							if (kind > 67)
								kind = 67;
							jjCheckNAdd(40);
						} else if (curChar == 47)
							jjAddStates(10, 11);
						else if (curChar == 34)
							jjCheckNAddStates(12, 14);
						else if (curChar == 46)
							jjCheckNAdd(10);
						else if (curChar == 39)
							jjCheckNAdd(8);
						if (BitHacker.and(X3FE000000000000, l).isNotZero()) {
							if (kind > 54)
								kind = 54;
							jjCheckNAddTwoStates(5, 6);
						} else if (curChar == 48) {
							if (kind > 54)
								kind = 54;
							jjCheckNAddStates(15, 17);
						} else if (curChar == 47)
							jjstateSet[jjnewStateCnt++] = 2;
						break;
					case 0:
						if (curChar == 42)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 1:
						if (BitHacker.and(XFFFF7FFFFFFFFFFF, l).isNotZero() && kind > 7)
							kind = 7;
						break;
					case 4:
						if (BitHacker.and(X3FE000000000000, l).isZero())
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddTwoStates(5, 6);
						break;
					case 5:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddTwoStates(5, 6);
						break;
					case 7:
						if (curChar == 39)
							jjCheckNAdd(8);
						break;
					case 8:
						if (BitHacker.and(X3000000000000, l).isZero())
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddTwoStates(8, 6);
						break;
					case 9:
						if (curChar == 46)
							jjCheckNAdd(10);
						break;
					case 10:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 59)
							kind = 59;
						jjCheckNAddStates(18, 20);
						break;
					case 12:
						if (BitHacker.and(X280000000000, l).isNotZero())
							jjCheckNAdd(13);
						break;
					case 13:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 59)
							kind = 59;
						jjCheckNAddTwoStates(13, 14);
						break;
					case 15:
						if (curChar == 34)
							jjCheckNAddStates(12, 14);
						break;
					case 16:
						if (BitHacker.and(XFFFFFFFBFFFFDBFF, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 18:
						if (BitHacker.and(X8400000000, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 19:
						if (curChar == 34 && kind > 61)
							kind = 61;
						break;
					case 20:
						if (BitHacker.and(XFF000000000000, l).isNotZero())
							jjCheckNAddStates(21, 24);
						break;
					case 21:
						if (BitHacker.and(XFF000000000000, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 22:
						if (BitHacker.and(XF000000000000, l).isNotZero())
							jjstateSet[jjnewStateCnt++] = 23;
						break;
					case 23:
						if (BitHacker.and(XFF000000000000, l).isNotZero())
							jjCheckNAdd(21);
						break;
					case 25:
					case 30:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAdd(26);
						break;
					case 26:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 28:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjstateSet[jjnewStateCnt++] = 29;
						break;
					case 29:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjstateSet[jjnewStateCnt++] = 30;
						break;
					case 31:
						if (curChar == 47)
							jjAddStates(10, 11);
						break;
					case 32:
						if (BitHacker.and(XFFFF7BFEFFFFDBFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						break;
					case 33:
						if (BitHacker.and(XFFFF7FFEFFFFDBFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						break;
					case 35:
						if (BitHacker.and(XFFFFFFFFFFFFDBFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						break;
					case 36:
						if (curChar != 47)
							break;
						if (kind > 63)
							kind = 63;
						jjstateSet[jjnewStateCnt++] = 37;
						break;
					case 39:
						if (curChar != 36)
							break;
						if (kind > 67)
							kind = 67;
						jjCheckNAdd(40);
						break;
					case 40:
						if (BitHacker.and(X3FF001000000000, l).isZero())
							break;
						if (kind > 67)
							kind = 67;
						jjCheckNAdd(40);
						break;
					case 41:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddStates(3, 9);
						break;
					case 42:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddTwoStates(42, 43);
						break;
					case 43:
						if (curChar == 46)
							jjCheckNAdd(44);
						break;
					case 44:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 59)
							kind = 59;
						jjCheckNAddStates(25, 27);
						break;
					case 46:
						if (BitHacker.and(X280000000000, l).isNotZero())
							jjCheckNAdd(47);
						break;
					case 47:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 59)
							kind = 59;
						jjCheckNAddTwoStates(47, 14);
						break;
					case 48:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddTwoStates(48, 49);
						break;
					case 50:
						if (BitHacker.and(X280000000000, l).isNotZero())
							jjCheckNAdd(51);
						break;
					case 51:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 59)
							kind = 59;
						jjCheckNAddTwoStates(51, 14);
						break;
					case 52:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddStates(28, 30);
						break;
					case 54:
						if (BitHacker.and(X280000000000, l).isNotZero())
							jjCheckNAdd(55);
						break;
					case 55:
						if (BitHacker.and(X3FF000000000000, l).isNotZero())
							jjCheckNAddTwoStates(55, 14);
						break;
					case 56:
						if (curChar != 48)
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddStates(15, 17);
						break;
					case 58:
						if (BitHacker.and(X3FF000000000000, l).isZero())
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddTwoStates(58, 6);
						break;
					case 59:
						if (BitHacker.and(XFF000000000000, l).isZero())
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddTwoStates(59, 6);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				Int64 l = BitHacker.shift1(curChar & 077);
				do {
					switch (jjstateSet[--i]) {
					case 60:
						if (BitHacker.and(XFFFFFFFFEFFFFFFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						else if (curChar == 92)
							jjCheckNAdd(35);
						break;
					case 2:
						if (BitHacker.and(XFFFFFFFFEFFFFFFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						else if (curChar == 92)
							jjCheckNAdd(35);
						break;
					case 3:
					case 40:
						if (BitHacker.and(X7FFFFFE87FFFFFE, l).isZero())
							break;
						if (kind > 67)
							kind = 67;
						jjCheckNAdd(40);
						break;
					case 1:
						if (kind > 7)
							kind = 7;
						break;
					case 6:
						if (BitHacker.and(X100000001000, l).isNotZero() && kind > 54)
							kind = 54;
						break;
					case 11:
						if (BitHacker.and(X2000000020, l).isNotZero())
							jjAddStates(31, 32);
						break;
					case 14:
						if (BitHacker.and(X5000000050, l).isNotZero() && kind > 59)
							kind = 59;
						break;
					case 16:
						if (BitHacker.and(XFFFFFFFFEFFFFFFF, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 17:
						if (curChar == 92)
							jjAddStates(33, 37);
						break;
					case 18:
						if (BitHacker.and(X14404410000000, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 24:
						if (curChar == 120)
							jjstateSet[jjnewStateCnt++] = 25;
						break;
					case 25:
					case 30:
						if (BitHacker.and(X7E0000007E, l).isNotZero())
							jjCheckNAdd(26);
						break;
					case 26:
						if (BitHacker.and(X7E0000007E, l).isNotZero())
							jjCheckNAddStates(12, 14);
						break;
					case 27:
						if (curChar == 117)
							jjstateSet[jjnewStateCnt++] = 28;
						break;
					case 28:
						if (BitHacker.and(X7E0000007E, l).isNotZero())
							jjstateSet[jjnewStateCnt++] = 29;
						break;
					case 29:
						if (BitHacker.and(X7E0000007E, l).isNotZero())
							jjstateSet[jjnewStateCnt++] = 30;
						break;
					case 32:
						if (BitHacker.and(XFFFFFFFFEFFFFFFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						break;
					case 33:
						if (BitHacker.and(XFFFFFFFFEFFFFFFF, l).isNotZero())
							jjCheckNAddStates(0, 2);
						break;
					case 34:
						if (curChar == 92)
							jjCheckNAdd(35);
						break;
					case 35:
						jjCheckNAddStates(0, 2);
						break;
					case 37:
						if (BitHacker.and(X7FFFFFE00000000, l).isZero())
							break;
						if (kind > 63)
							kind = 63;
						jjstateSet[jjnewStateCnt++] = 37;
						break;
					case 38:
						if (curChar == 92)
							jjCheckNAdd(35);
						break;
					case 45:
						if (BitHacker.and(X2000000020, l).isNotZero())
							jjAddStates(38, 39);
						break;
					case 49:
						if (BitHacker.and(X2000000020, l).isNotZero())
							jjAddStates(40, 41);
						break;
					case 53:
						if (BitHacker.and(X2000000020, l).isNotZero())
							jjAddStates(42, 43);
						break;
					case 57:
						if (BitHacker.and(X100000001000000, l).isNotZero())
							jjCheckNAdd(58);
						break;
					case 58:
						if (BitHacker.and(X7E0000007E, l).isZero())
							break;
						if (kind > 54)
							kind = 54;
						jjCheckNAddTwoStates(58, 6);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				Int64 l1 = BitHacker.shift1(hiByte & 077);
				int i2 = (curChar & 0xFF) >> 6;
				Int64 l2 = BitHacker.shift1(curChar & 077);
				do {
					switch (jjstateSet[--i]) {
					case 60:
					case 33:
					case 35:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjCheckNAddStates(0, 2);
						break;
					case 2:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjCheckNAddStates(0, 2);
						break;
					case 3:
					case 40:
						if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
							break;
						if (kind > 67)
							kind = 67;
						jjCheckNAdd(40);
						break;
					case 1:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
							kind = 7;
						break;
					case 16:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjAddStates(12, 14);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7FFFFFFF) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7FFFFFFF;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 60 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = ASCII_UCodeESC_CharStream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static private final int jjMoveStringLiteralDfa0_5() {
		switch (curChar) {
		case 42:
			return jjMoveStringLiteralDfa1_5(X10000);
		default:
			return 1;
		}
	}

	static private final int jjMoveStringLiteralDfa1_5(Int64 active0) {
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			return 1;
		}
		switch (curChar) {
		case 47:
			if (BitHacker.and(active0, X10000).isNotZero())
				return jjStopAtPos(1, 16);
			break;
		default:
			return 2;
		}
		return 2;
	}

	private static final int jjStopStringLiteralDfa_3(int pos, Int64 active0) {
		switch (pos) {
		default:
			return -1;
		}
	}

	private static final int jjStartNfa_3(int pos, Int64 active0) {
		return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
	}

	static private final int jjMoveStringLiteralDfa0_3() {
		switch (curChar) {
		case 114:
			return jjMoveStringLiteralDfa1_3(X2000);
		default:
			return jjMoveNfa_3(4, 0);
		}
	}

	static private final int jjMoveStringLiteralDfa1_3(Int64 active0) {
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_3(0, active0);
			return 1;
		}
		switch (curChar) {
		case 101:
			return jjMoveStringLiteralDfa2_3(active0, X2000);
		default:
			break;
		}
		return jjStartNfa_3(0, active0);
	}

	static private final int jjMoveStringLiteralDfa2_3(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_3(0, old0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_3(1, active0);
			return 2;
		}
		switch (curChar) {
		case 116:
			return jjMoveStringLiteralDfa3_3(active0, X2000);
		default:
			break;
		}
		return jjStartNfa_3(1, active0);
	}

	static private final int jjMoveStringLiteralDfa3_3(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_3(1, old0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_3(2, active0);
			return 3;
		}
		switch (curChar) {
		case 117:
			return jjMoveStringLiteralDfa4_3(active0, X2000);
		default:
			break;
		}
		return jjStartNfa_3(2, active0);
	}

	static private final int jjMoveStringLiteralDfa4_3(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_3(2, old0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_3(3, active0);
			return 4;
		}
		switch (curChar) {
		case 114:
			return jjMoveStringLiteralDfa5_3(active0, X2000);
		default:
			break;
		}
		return jjStartNfa_3(3, active0);
	}

	static private final int jjMoveStringLiteralDfa5_3(Int64 old0, Int64 active0) {
		active0 = BitHacker.and(active0, old0);
		if (BitHacker.equals0(active0))
			return jjStartNfa_3(3, old0);
		try {
			curChar = ASCII_UCodeESC_CharStream.readChar();
		} catch (java.io.IOException e) {
			jjStopStringLiteralDfa_3(4, active0);
			return 5;
		}
		switch (curChar) {
		case 110:
			if (BitHacker.and(active0, X2000).isNotZero())
				return jjStopAtPos(5, 13);
			break;
		default:
			break;
		}
		return jjStartNfa_3(4, active0);
	}

	static private final int jjMoveNfa_3(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 11;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7FFFFFFF;
		for (;;) {
			if (++jjround == 0x7FFFFFFF)
				ReInitRounds();
			if (curChar < 64) {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				do {
					switch (jjstateSet[--i]) {
					case 4:
						if (curChar == 116)
							jjstateSet[jjnewStateCnt++] = 9;
						else if (curChar == 112)
							jjstateSet[jjnewStateCnt++] = 3;
						break;
					case 0:
						if (curChar == 109)
							kind = 12;
						break;
					case 1:
						if (curChar == 97)
							jjstateSet[jjnewStateCnt++] = 0;
						break;
					case 2:
						if (curChar == 114)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 3:
						if (curChar == 97)
							jjstateSet[jjnewStateCnt++] = 2;
						break;
					case 5:
						if (curChar == 115)
							kind = 12;
						break;
					case 6:
						if (curChar == 119)
							jjstateSet[jjnewStateCnt++] = 5;
						break;
					case 7:
						if (curChar == 111)
							jjstateSet[jjnewStateCnt++] = 6;
						break;
					case 8:
						if (curChar == 114)
							jjstateSet[jjnewStateCnt++] = 7;
						break;
					case 9:
						if (curChar == 104)
							jjstateSet[jjnewStateCnt++] = 8;
						break;
					case 10:
						if (curChar == 116)
							jjstateSet[jjnewStateCnt++] = 9;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7FFFFFFF) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7FFFFFFF;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 11 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = ASCII_UCodeESC_CharStream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static private final int jjMoveStringLiteralDfa0_1() {
		return jjMoveNfa_1(0, 0);
	}

	static private final int jjMoveNfa_1(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 3;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7FFFFFFF;
		for (;;) {
			if (++jjround == 0x7FFFFFFF)
				ReInitRounds();
			if (curChar < 64) {
				Int64 l = BitHacker.shift1(curChar);
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if (BitHacker.and(X2400, l).isNotZero()) {
							if (kind > 10)
								kind = 10;
						}
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 1:
						if (curChar == 10 && kind > 10)
							kind = 10;
						break;
					case 2:
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7FFFFFFF) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7FFFFFFF;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = ASCII_UCodeESC_CharStream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static private final int jjMoveStringLiteralDfa0_6() {
		return jjMoveNfa_6(0, 0);
	}

	static private final int jjMoveNfa_6(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 3;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7FFFFFFF;
		for (;;) {
			if (++jjround == 0x7FFFFFFF)
				ReInitRounds();
			if (curChar < 64) {
				Int64 l = BitHacker.shift1(curChar);
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if (BitHacker.and(X2400, l).isNotZero()) {
							if (kind > 17)
								kind = 17;
						}
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					case 1:
						if (curChar == 10 && kind > 17)
							kind = 17;
						break;
					case 2:
						if (curChar == 13)
							jjstateSet[jjnewStateCnt++] = 1;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7FFFFFFF) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7FFFFFFF;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = ASCII_UCodeESC_CharStream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static private final int jjMoveStringLiteralDfa0_2() {
		return jjMoveNfa_2(1, 0);
	}

	static private final int jjMoveNfa_2(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 3;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7FFFFFFF;
		for (;;) {
			if (++jjround == 0x7FFFFFFF)
				ReInitRounds();
			if (curChar < 64) {
				do {
					switch (jjstateSet[--i]) {
					case 1:
						if (curChar == 42)
							jjstateSet[jjnewStateCnt++] = 0;
						break;
					case 0:
						if (curChar == 47)
							kind = 11;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				do {
					switch (jjstateSet[--i]) {
					case 1:
						if (curChar == 64)
							kind = 11;
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7FFFFFFF) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7FFFFFFF;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = ASCII_UCodeESC_CharStream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static private final int jjMoveStringLiteralDfa0_4() {
		return jjMoveNfa_4(0, 0);
	}

	static private final int jjMoveNfa_4(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 3;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7FFFFFFF;
		for (;;) {
			if (++jjround == 0x7FFFFFFF)
				ReInitRounds();
			if (curChar < 64) {
				Int64 l = BitHacker.shift1(curChar);
				do {
					switch (jjstateSet[--i]) {
					case 0:
						if (curChar == 32)
							jjCheckNAddTwoStates(0, 1);
						break;
					case 1:
						if (BitHacker.and(XFFFFFFFEFFFFFFFF, l).isNotZero())
							jjCheckNAddTwoStates(1, 2);
						break;
					case 2:
						if (curChar != 32)
							break;
						if (kind > 14)
							kind = 14;
						jjCheckNAdd(2);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				do {
					switch (jjstateSet[--i]) {
					case 1:
						jjAddStates(44, 45);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				int hiByte = (int) (curChar >> 8);
				int i1 = hiByte >> 6;
				Int64 l1 = BitHacker.shift1(hiByte & 077);
				int i2 = (curChar & 0xFF) >> 6;
				Int64 l2 = BitHacker.shift1(curChar & 077);
				do {
					switch (jjstateSet[--i]) {
					case 1:
						if (jjCanMove_0(hiByte, i1, i2, l1, l2))
							jjAddStates(44, 45);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7FFFFFFF) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7FFFFFFF;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))
				return curPos;
			try {
				curChar = ASCII_UCodeESC_CharStream.readChar();
			} catch (java.io.IOException e) {
				return curPos;
			}
		}
	}

	static final int[] jjnextStates = { 33, 34, 36, 42, 43, 48, 49, 52, 53, 14, 32, 38, 16, 17, 19, 57, 59, 6, 10, 11,
			14, 16, 17, 21, 19, 44, 45, 14, 52, 53, 14, 12, 13, 18, 20, 22, 24, 27, 46, 47, 50, 51, 54, 55, 1, 2, };

	private static final boolean jjCanMove_0(int hiByte, int i1, int i2, Int64 l1, Int64 l2) {
		switch (hiByte) {
		case 0:
			return (BitHacker.and(BitHacker.jjbitVec2[i2], l2).isNotZero());
		default:
			if (BitHacker.and(BitHacker.jjbitVec0[i1], l1).isNotZero())
				return true;
			return false;
		}
	}

	private static final boolean jjCanMove_1(int hiByte, int i1, int i2, Int64 l1, Int64 l2) {
		switch (hiByte) {
		case 0:
			return (BitHacker.and(BitHacker.jjbitVec4[i2], l2).isNotZero());
		case 48:
			return (BitHacker.and(BitHacker.jjbitVec5[i2], l2).isNotZero());
		case 49:
			return (BitHacker.and(BitHacker.jjbitVec6[i2], l2).isNotZero());
		case 51:
			return (BitHacker.and(BitHacker.jjbitVec7[i2], l2).isNotZero());
		case 61:
			return (BitHacker.and(BitHacker.jjbitVec8[i2], l2).isNotZero());
		default:
			if (BitHacker.and(BitHacker.jjbitVec3[i1], l1).isNotZero())
				return true;
			return false;
		}
	}

	public static final String[] jjstrLiteralImages = { "", null, null, null, null, null, null, null, null, null, null,
			null, null, null, null, null, null, null, null, "\142\162\145\141\153", "\143\141\154\154\145\145",
			"\143\141\164\143\150", "\143\157\156\163\164", "\143\157\156\164\151\156\165\145", "\144\157", "\56\56\56",
			"\145\154\163\145", "\145\170\164\145\156\144\163", "\145\166\141\154", "\146\141\154\163\145",
			"\146\151\156\141\154\154\171", "\146\157\162", "\146\165\156\143\164\151\157\156", "\151\146",
			"\151\156\163\164\141\156\143\145\157\146", "\151\155\160\157\162\164", "\155\151\170\151\156",
			"\156\145\167", "\156\165\154\154", "\160\162\151\166\141\164\145", "\160\162\157\164\145\143\164\145\144",
			"\160\165\142\154\151\143", "\162\145\164\165\162\156", "\163\164\141\164\151\143", "\163\165\160\145\162",
			"\163\171\156\143\150\162\157\156\151\172\145\144", "\164\150\151\163", "\164\150\162\157\167",
			"\164\162\165\145", "\164\162\171", "\165\156\144\145\146\151\156\145\144", "\166\141\162",
			"\166\157\151\144", "\167\150\151\154\145", null, null, null, null, null, null, null, null, null, null,
			null, null, null, null, null, null, "\50", "\51", "\47\173", "\173", "\175", "\133", "\135", "\73", "\54",
			"\56", "\75", "\76", "\74", "\41", "\176", "\77", "\72", "\75\75", "\74\75", "\76\75", "\41\75", "\174\174",
			"\46\46", "\53\53", "\55\55", "\53", "\55", "\52", "\57", "\46", "\174", "\136", "\45", "\74\74", "\76\76",
			"\76\76\76", "\53\75", "\55\75", "\52\75", "\57\75", "\46\75", "\174\75", "\136\75", "\45\75", "\74\74\75",
			"\76\76\75", "\76\76\76\75", "\56\56", };
	public static final String[] lexStateNames = { "DEFAULT", "IN_SINGLE_LINE_COMMENT", "IN_FORMAL_COMMENT",
			"MAYBE_JAVADOC_TAG", "EXPECTING_JAVADOC_TAG_ARG", "IN_MULTI_LINE_COMMENT",
			"IN_UNIX_SELF_EXECUTABLE_COMMENT", };
	public static final int[] jjnewLexState = { -1, -1, -1, -1, -1, -1, 1, 2, 5, 6, 0, 3, 4, 2, 2, -1, 0, 0, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, };
	static private ASCII_UCodeESC_CharStream input_stream;
	static private final int[] jjrounds = new int[60];
	static private final int[] jjstateSet = new int[120];
	static StringBuffer image;
	static int jjimageLen;
	static int lengthOfMatch;
	static protected char curChar;

	public OscriptParserTokenManager(ASCII_UCodeESC_CharStream stream) {
		if (input_stream != null)
			throw new TokenMgrError(
					"ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.",
					TokenMgrError.STATIC_LEXER_ERROR);
		input_stream = stream;
	}

	public OscriptParserTokenManager(ASCII_UCodeESC_CharStream stream, int lexState) {
		this(stream);
		SwitchTo(lexState);
	}

	static public void ReInit(ASCII_UCodeESC_CharStream stream) {
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}

	static private final void ReInitRounds() {
		int i;
		jjround = 0x80000001;
		for (i = 60; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	static public void ReInit(ASCII_UCodeESC_CharStream stream, int lexState) {
		ReInit(stream);
		SwitchTo(lexState);
	}

	static public void SwitchTo(int lexState) {
		if (lexState >= 7 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.",
					TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	static private final Token jjFillToken() {
		Token t = Token.newToken(jjmatchedKind);
		t.kind = jjmatchedKind;
		String im = jjstrLiteralImages[jjmatchedKind];
		t.image = (im == null) ? ASCII_UCodeESC_CharStream.GetImage() : im;
		t.beginLine = ASCII_UCodeESC_CharStream.getBeginLine();
		t.beginColumn = ASCII_UCodeESC_CharStream.getBeginColumn();
		t.endLine = ASCII_UCodeESC_CharStream.getEndLine();
		t.endColumn = ASCII_UCodeESC_CharStream.getEndColumn();
		t.beginOffset = ASCII_UCodeESC_CharStream.getBeginOffset();
		t.endOffset = ASCII_UCodeESC_CharStream.getEndOffset();

		return t;
	}

	static int curLexState = 0;
	static int defaultLexState = 0;
	static int jjnewStateCnt;
	static int jjround;
	static int jjmatchedPos;
	static int jjmatchedKind;

	public static final Token getNextToken() {
		Token specialToken = null;
		Token matchedToken;
		int curPos = 0;

		EOFLoop: for (;;) {
			try {
				curChar = ASCII_UCodeESC_CharStream.BeginToken();
			} catch (java.io.IOException e) {
				jjmatchedKind = 0;
				matchedToken = jjFillToken();
				matchedToken.specialToken = specialToken;
				return matchedToken;
			}
			image = null;
			jjimageLen = 0;

			for (;;) {
				switch (curLexState) {
				case 0:
					try {
						ASCII_UCodeESC_CharStream.backup(0);
						while (curChar <= 32 && BitHacker.and(X100003600, BitHacker.shift1(curChar)).isNotZero())
							curChar = ASCII_UCodeESC_CharStream.BeginToken();
					} catch (java.io.IOException e1) {
						continue EOFLoop;
					}
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_0();
					break;
				case 1:
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_1();
					if (jjmatchedPos == 0 && jjmatchedKind > 18) {
						jjmatchedKind = 18;
					}
					break;
				case 2:
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_2();
					if (jjmatchedPos == 0 && jjmatchedKind > 18) {
						jjmatchedKind = 18;
					}
					break;
				case 3:
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_3();
					if (jjmatchedPos == 0 && jjmatchedKind > 15) {
						jjmatchedKind = 15;
					}
					break;
				case 4:
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_4();
					break;
				case 5:
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_5();
					if (jjmatchedPos == 0 && jjmatchedKind > 18) {
						jjmatchedKind = 18;
					}
					break;
				case 6:
					jjmatchedKind = 0x7FFFFFFF;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_6();
					if (jjmatchedPos == 0 && jjmatchedKind > 18) {
						jjmatchedKind = 18;
					}
					break;
				}
				if (jjmatchedKind != 0x7FFFFFFF) {
					if (jjmatchedPos + 1 < curPos)
						ASCII_UCodeESC_CharStream.backup(curPos - jjmatchedPos - 1);
					if (BitHacker.and(BitHacker.jjtoToken[jjmatchedKind >> 6], BitHacker.shift1((jjmatchedKind & 077))).isNotZero()) {
						matchedToken = jjFillToken();
						matchedToken.specialToken = specialToken;
						if (jjnewLexState[jjmatchedKind] != -1)
							curLexState = jjnewLexState[jjmatchedKind];
						return matchedToken;
					} else if (BitHacker.and(BitHacker.jjtoSkip[jjmatchedKind >> 6], BitHacker.shift1((jjmatchedKind & 077))).isNotZero()) {
						if (BitHacker.and(BitHacker.jjtoSpecial[jjmatchedKind >> 6], BitHacker.shift1((jjmatchedKind & 077))).isNotZero()) {
							matchedToken = jjFillToken();
							if (specialToken == null)
								specialToken = matchedToken;
							else {
								matchedToken.specialToken = specialToken;
								specialToken = (specialToken.next = matchedToken);
							}
							SkipLexicalActions(matchedToken);
						} else
							SkipLexicalActions(null);
						if (jjnewLexState[jjmatchedKind] != -1)
							curLexState = jjnewLexState[jjmatchedKind];
						continue EOFLoop;
					}
					MoreLexicalActions();
					if (jjnewLexState[jjmatchedKind] != -1)
						curLexState = jjnewLexState[jjmatchedKind];
					curPos = 0;
					jjmatchedKind = 0x7FFFFFFF;
					try {
						curChar = ASCII_UCodeESC_CharStream.readChar();
						continue;
					} catch (java.io.IOException e1) {
					}
				}
				int error_line = ASCII_UCodeESC_CharStream.getEndLine();
				int error_column = ASCII_UCodeESC_CharStream.getEndColumn();
				String error_after = null;
				boolean EOFSeen = false;
				try {
					ASCII_UCodeESC_CharStream.readChar();
					ASCII_UCodeESC_CharStream.backup(1);
				} catch (java.io.IOException e1) {
					EOFSeen = true;
					error_after = curPos <= 1 ? "" : ASCII_UCodeESC_CharStream.GetImage();
					if (curChar == '\n' || curChar == '\r') {
						error_line++;
						error_column = 0;
					} else
						error_column++;
				}
				if (!EOFSeen) {
					ASCII_UCodeESC_CharStream.backup(1);
					error_after = curPos <= 1 ? "" : ASCII_UCodeESC_CharStream.GetImage();
				}
				throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar,
						TokenMgrError.LEXICAL_ERROR);
			}
		}
	}

	static final void SkipLexicalActions(Token matchedToken) {
		switch (jjmatchedKind) {
		case 11:
			if (image == null)
				image = new StringBuffer(new String(
						ASCII_UCodeESC_CharStream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
			else
				image.append(ASCII_UCodeESC_CharStream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
			stillInFormalComment = image.toString().endsWith("@");
			break;
		default:
			break;
		}
	}

	static final void MoreLexicalActions() {
		jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
		switch (jjmatchedKind) {
		case 7:
			if (image == null)
				image = new StringBuffer(new String(ASCII_UCodeESC_CharStream.GetSuffix(jjimageLen)));
			else
				image.append(ASCII_UCodeESC_CharStream.GetSuffix(jjimageLen));
			jjimageLen = 0;
			ASCII_UCodeESC_CharStream.backup(1);
			break;
		case 15:
			if (image == null)
				image = new StringBuffer(new String(ASCII_UCodeESC_CharStream.GetSuffix(jjimageLen)));
			else
				image.append(ASCII_UCodeESC_CharStream.GetSuffix(jjimageLen));
			jjimageLen = 0;
			ASCII_UCodeESC_CharStream.backup(1);
			if (stillInFormalComment)
				SwitchTo(IN_FORMAL_COMMENT);
			else
				SwitchTo(DEFAULT);
			break;
		default:
			break;
		}
	}
	
	
	static Int64 X2000000 = new Int64("2000000");
	static Int64 X20000000008000 = new Int64("20000000008000");
	static Int64 X140 = new Int64("140");
	static Int64 X200400000000 = new Int64("200400000000");
	static Int64 X100 = new Int64("100");
	static Int64 X3FFFFFFDF80000 = new Int64("3FFFFFFDF80000");
	static Int64 X3FFFFDFCF80000 = new Int64("3FFFFDFCF80000");
	static Int64 X201000000 = new Int64("201000000");
	static Int64 X200000000000 = new Int64("200000000000");
	static Int64 X35FFDD7CF80000 = new Int64("35FFDD7CF80000");
	static Int64 XA002080000000 = new Int64("A002080000000");
	static Int64 X24BF9D68F80000 = new Int64("24BF9D68F80000");
	static Int64 X11404014000000 = new Int64("11404014000000");
	static Int64 X42F8D48900000 = new Int64("42F8D48900000");
	static Int64 X20901020680000 = new Int64("20901020680000");
	static Int64 X4218548800000 = new Int64("4218548800000");
	static Int64 XE0800100000 = new Int64("E0800100000");
	static Int64 X4210500800000 = new Int64("4210500800000");
	static Int64 X8048000000 = new Int64("8048000000");
	static Int64 X100800000 = new Int64("100800000");
	static Int64 X4210400000000 = new Int64("4210400000000");
	static Int64 X4010000000000 = new Int64("4010000000000");
	static Int64 X400000000 = new Int64("400000000");
	static Int64 X0 = new Int64("0");
	static Int64 X4000000 = new Int64("4000000");
	static Int64 X200 = new Int64("200");
	static Int64 X2000000000000 = new Int64("2000000000000");
	static Int64 X400010000000 = new Int64("400010000000");
	static Int64 X100000000000 = new Int64("100000000000");
	static Int64 X40020000000 = new Int64("40020000000");
	static Int64 X80040000000 = new Int64("80040000000");
	static Int64 X20000000000000 = new Int64("20000000000000");
	static Int64 X4008001000000 = new Int64("4008001000000");
	static Int64 X800000 = new Int64("800000");
	static Int64 X18030002000000 = new Int64("18030002000000");
	static Int64 X1000000000000 = new Int64("1000000000000");
	static Int64 X80000 = new Int64("80000");
	static Int64 XF00000 = new Int64("F00000");
	static Int64 X1000000 = new Int64("1000000");
	static Int64 X1C000000 = new Int64("1C000000");
	static Int64 X1E0000000 = new Int64("1E0000000");
	static Int64 XE00000000 = new Int64("E00000000");
	static Int64 X1000000000 = new Int64("1000000000");
	static Int64 X6000000000 = new Int64("6000000000");
	static Int64 X38000000000 = new Int64("38000000000");
	static Int64 X40000000000 = new Int64("40000000000");
	static Int64 X380000000000 = new Int64("380000000000");
	static Int64 X3C00000000000 = new Int64("3C00000000000");
	static Int64 X4000000000000 = new Int64("4000000000000");
	static Int64 X18000000000000 = new Int64("18000000000000");
	static Int64 X800008000000 = new Int64("800008000000");
	static Int64 X10000000 = new Int64("10000000");
	static Int64 X20000000 = new Int64("20000000");
	static Int64 X40000000 = new Int64("40000000");
	static Int64 X40 = new Int64("40");
	static Int64 X8000000000 = new Int64("8000000000");
	static Int64 X80000000000 = new Int64("80000000000");
	static Int64 X400000000000 = new Int64("400000000000");
	static Int64 X800000000000 = new Int64("800000000000");
	static Int64 X10000000000 = new Int64("10000000000");
	static Int64 X18020000000000 = new Int64("18020000000000");
	static Int64 X8000020300000 = new Int64("8000020300000");
	static Int64 X42000000000 = new Int64("42000000000");
	static Int64 X200000000 = new Int64("200000000");
	static Int64 X20C00000000000 = new Int64("20C00000000000");
	static Int64 X1040000000 = new Int64("1040000000");
	static Int64 X800000000 = new Int64("800000000");
	static Int64 X4000400000000 = new Int64("4000400000000");
	static Int64 X10000080C00000 = new Int64("10000080C00000");
	static Int64 X3018000080000 = new Int64("3018000080000");
	static Int64 X124100000000 = new Int64("124100000000");
	static Int64 X8000000 = new Int64("8000000");
	static Int64 X8000000000000 = new Int64("8000000000000");
	static Int64 X20000000000 = new Int64("20000000000");
	static Int64 X10000000000000 = new Int64("10000000000000");
	static Int64 X80010000000 = new Int64("80010000000");
	static Int64 X30408000000000 = new Int64("30408000000000");
	static Int64 X4020100000 = new Int64("4020100000");
	static Int64 X200140C00000 = new Int64("200140C00000");
	static Int64 X100800000000 = new Int64("100800000000");
	static Int64 X80000000 = new Int64("80000000");
	static Int64 X404000000 = new Int64("404000000");
	static Int64 X40008200000 = new Int64("40008200000");
	static Int64 X2000000000 = new Int64("2000000000");
	static Int64 X40080000 = new Int64("40080000");
	static Int64 X200100200000 = new Int64("200100200000");
	static Int64 X4100008000000 = new Int64("4100008000000");
	static Int64 X4000000000 = new Int64("4000000000");
	static Int64 X20020000100000 = new Int64("20020000100000");
	static Int64 X800800000000 = new Int64("800800000000");
	static Int64 X20400000 = new Int64("20400000");
	static Int64 X90400800000 = new Int64("90400800000");
	static Int64 X8400000000 = new Int64("8400000000");
	static Int64 X10000100000 = new Int64("10000100000");
	static Int64 X200000 = new Int64("200000");
	static Int64 XA0000800000 = new Int64("A0000800000");
	static Int64 X40800000000 = new Int64("40800000000");
	static Int64 X400000 = new Int64("400000");
	static Int64 X100000000 = new Int64("100000000");
	static Int64 X100000 = new Int64("100000");
	static Int64 X4000100000000 = new Int64("4000100000000");
	static Int64 X400800000 = new Int64("400800000");
	static Int64 X200100000000 = new Int64("200100000000");
	static Int64 X4010400000000 = new Int64("4010400000000");
	static Int64 X7FFFFFFF = new Int64("7FFFFFFF");
	static Int64 XFFFF7FFEFFFFDBFF = new Int64("FFFF7FFEFFFFDBFF");
	static Int64 XFFFF7BFEFFFFDBFF = new Int64("FFFF7BFEFFFFDBFF");
	static Int64 X3FF000000000000 = new Int64("3FF000000000000");
	static Int64 X3FE000000000000 = new Int64("3FE000000000000");
	static Int64 XFFFF7FFFFFFFFFFF = new Int64("FFFF7FFFFFFFFFFF");
	static Int64 X3000000000000 = new Int64("3000000000000");
	static Int64 X280000000000 = new Int64("280000000000");
	static Int64 XFFFFFFFBFFFFDBFF = new Int64("FFFFFFFBFFFFDBFF");
	static Int64 XFF000000000000 = new Int64("FF000000000000");
	static Int64 XF000000000000 = new Int64("F000000000000");
	static Int64 XFFFFFFFFFFFFDBFF = new Int64("FFFFFFFFFFFFDBFF");
	static Int64 X3FF001000000000 = new Int64("3FF001000000000");
	static Int64 XFFFFFFFFEFFFFFFF = new Int64("FFFFFFFFEFFFFFFF");
	static Int64 X7FFFFFE87FFFFFE = new Int64("7FFFFFE87FFFFFE");
	static Int64 X100000001000 = new Int64("100000001000");
	static Int64 X2000000020 = new Int64("2000000020");
	static Int64 X5000000050 = new Int64("5000000050");
	static Int64 X14404410000000 = new Int64("14404410000000");
	static Int64 X7E0000007E = new Int64("7E0000007E");
	static Int64 X7FFFFFE00000000 = new Int64("7FFFFFE00000000");
	static Int64 X100000001000000 = new Int64("100000001000000");
	static Int64 XFF = new Int64("FF");
	static Int64 X10000 = new Int64("10000");
	static Int64 X2000 = new Int64("2000");
	static Int64 X2400 = new Int64("2400");
	static Int64 XFFFFFFFEFFFFFFFF = new Int64("FFFFFFFEFFFFFFFF");
	static Int64 X80000001 = new Int64("80000001");
	static Int64 X100003600 = new Int64("100003600");
	
}
